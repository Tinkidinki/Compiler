 %{     #include "code_generation.cpp"
	#include <bits/stdc++.h>
        #include <fstream>
        using namespace std;

        union ASTnode{
        int int_val;
        bool bool_val;
        char char_val;
        char* str_val;
        char* symbol;
        class Node* node;
        class List* node_list;
        };

        typedef union ASTnode YYSTYPE;
        int ARG_CHECK = 0;

        // #define YYSTYPE int
        
	extern  int yylex();
        extern  int yyparse ();
        extern char* yytext;
        extern FILE* yyin;
	void yyerror(const char *s);

        class Node* start = NULL;
        // extern YYSTYPE yylval;

%}

/*-----------------------------TOKENS----------------------------- */
%token <int_val> INT_LITERAL 
%token <bool_val> BOOL_LITERAL
%token <char_val> CHAR_LITERAL
%token <str_val> STRING_LITERAL 
%token <symbol> MINUS
%token <symbol> NOT
%token <symbol> ID
%token <symbol> LID
%token <symbol> ARITH_OP
%token <symbol> REL_OP
%token <symbol> EQ_OP 
%token <symbol> COND_OP
%token <symbol> LEFT_ROUND
%token <symbol> RIGHT_ROUND
%token <symbol> TYPE


%token  BAD_CHAR
        COMMA SEMICOLON EQUALS QUESTION_MARK COLON
      
        LEFT_SQUARE RIGHT_SQUARE LEFT_CURLY RIGHT_CURLY
       
        CALLOUT IF ELSE FOR WHILE RETURN BREAK CONTINUE CLASS PROGRAM

%left   MINUS NOT 
%left   ARITH_OP REL_OP EQ_OP COND_OP 
/*----------------------------------------------------------------*/

%type <node> literal 
%type <node> expr
%type <node> location
%type <node> identifier
%type <node> statement
%type <node_list> callout_args
%type <node_list> var_decls
%type <node_list> statements
%type <node> method_call
%type <node> block
%type <node> var_decl
%type <node> composite_type
%type <node> method_decl
%type <node_list> method_decls
%type <node_list> parameters
%type <node> program
%%

Goal: program

program:        CLASS PROGRAM LEFT_CURLY var_decls method_decls RIGHT_CURLY{ 
                        $$ = new ProgramVarMethod($4, $5); start = $$; 
                        printf("program -> CLASS PROGRAM LEFT_CURLY var_decls method_decls RIGHT_CURLY \n");
                }

       |        CLASS PROGRAM LEFT_CURLY method_decls RIGHT_CURLY {
                        $$ = new ProgramMethod($4); start = $$;
                        printf("program -> CLASS PROGRAM LEFT_CURLY method_decls RIGHT_CURLY \n");
                }

method_decl:    composite_type ID LEFT_ROUND parameters RIGHT_ROUND block {
                        $$ = new MethodDeclParam($1, $2, $4, $6); 
                        printf("method_decl -> composite_type ID LEFT_ROUND parameters RIGHT_ROUND block\n");
                }

       |        composite_type ID LEFT_ROUND RIGHT_ROUND block {
                        $$ = new MethodDeclEmpty($1, $2, $5);
                        start = $$;
                        printf("method_decl -> composite_type ID LEFT_ROUND RIGHT_ROUND block\n");
                }

method_decls:   method_decl  {
                        $$ = new MethodDecls(); $$->list.push_back($1); 
                        printf("method_decls -> method_decl\n");
                }

        |       method_decls method_decl {
                        $$->list.push_back($2); 
                        printf("method_decls -> method_decls method_decl \n");
                }

parameters:     composite_type ID {
                        $$ = new Parameters();  
                        Node* id = new Identifier($2); $$->list.push_back(id); 
                        $$->list.push_back($1);
                        printf("parameters -> composite_type ID \n");
                }

        |       parameters COMMA composite_type ID {
                        Node* id = new Identifier($4); $$->list.push_back(id); 
                        $$->list.push_back($3); 
                        printf("parameters -> parameters COMMA composite_type ID \n");
                }
        
composite_type: TYPE {
                        $$ = new Type($1); 
                        printf("composite_type -> TYPE\n");
                }

        |       TYPE LEFT_SQUARE INT_LITERAL RIGHT_SQUARE {
                        $$ = new ArrayType1D($1, $3);
                        printf("composite_type -> TYPE LEFT_SQUARE INT_LITERAL RIGHT_SQUARE\n");
                }
        |       TYPE LEFT_SQUARE INT_LITERAL RIGHT_SQUARE LEFT_SQUARE INT_LITERAL RIGHT_SQUARE {
                        $$ = new ArrayType2D($1, $3, $6);
                        printf("composite_type -> TYPE LEFT_SQUARE INT_LITERAL RIGHT_SQUARE LEFT_SQUARE INT_LITERAL RIGHT_SQUARE \n");
                }


block:          LEFT_CURLY var_decls statements RIGHT_CURLY {
                        $$ = new DecBlock($2, $3); 
                        printf("block -> LEFT_CURLY var_decls statements RIGHT_CURLY\n"); 
                }

        |       LEFT_CURLY statements RIGHT_CURLY {
                        $$ = new StatBlock($2); 
                        printf("block -> LEFT_CURLY statements RIGHT_CURLY\n");
                }

var_decls:      var_decl {
                        $$ = new VarDecls(); $$->list.push_back($1); 
                        printf("var_decls -> var_decl\n");
                }

        |       var_decls var_decl {
                        $$->list.push_back($2); 
                        printf("var_decls-> var_decls var_decl\n");
                }

var_decl:       composite_type ID SEMICOLON {
                        $$ = new VarDecl($1, $2);  
                        printf("var_decl -> composite_type ID SEMICOLON\n");
                }


statements:     statement  {
                        $$ = new Statements(); $$->list.push_back($1); 
                        printf("statements -> statement\n");
                }
        |       statements statement  {
                        $$ = $1; $$->list.push_back($2); 
                        printf("statements -> statements statement\n");
                }

statement:      identifier EQUALS expr SEMICOLON  {
                        $$ = new AssignmentStatement($1, $3); 
                        printf("statement -> location EQUALS expr SEMICOLON \n"); 
                } 

        |       method_call SEMICOLON  {
                        $$ = $1; 
                        printf("statement -> method_call SEMICOLON \n"); 
                } 

        |       IF LEFT_ROUND expr RIGHT_ROUND block  { 
                        $$ = new IfThenStatement($3, $5); 
                        printf("statement -> IF LEFT_ROUND expr RIGHT_ROUND statement \n");
                }

        |       IF LEFT_ROUND expr RIGHT_ROUND block ELSE block  {
                        $$ = new IfThenElseStatement($3, $5, $7); 
                        printf("statement -> IF LEFT_ROUND expr RIGHT_ROUND statement ELSE statement \n");
                }

        |       expr  QUESTION_MARK statement COLON statement  {
                        $$ = new TernaryIfStatement($1,$3, $5); 
                        printf("statement -> expr  QUESTION_MARK statement COLON statement \n");
                }

        |       WHILE LEFT_ROUND expr RIGHT_ROUND block {
                        $$ = new WhileStatement($3, $5); 
                        printf("statement -> WHILE LEFT_ROUND expr RIGHT_ROUND statement \n");
                }

        |       FOR LEFT_ROUND ID EQUALS expr SEMICOLON expr SEMICOLON ID EQUALS expr RIGHT_ROUND block {
                        $$ = new ForStatement($3, $5, $7, $9, $11, $13); 
                        printf("statement -> FOR LEFT_ROUND ID EQUALS expr SEMICOLON expr SEMICOLON ID EQUALS expr RIGHT_ROUND statement \n");}

        |       RETURN expr SEMICOLON {
                        $$ = new ReturnStatement($2); 
                        printf("statement -> RETURN expr SEMICOLON \n");
                }

        |       BREAK SEMICOLON {
                        $$ = new BreakStatement(); 
                        printf("statement -> BREAK SEMICOLON \n");
                }

        |       CONTINUE SEMICOLON {
                        $$ = new ContinueStatement(); 
                        printf("statement -> CONTINUE SEMICOLON \n");
                }


expr:           literal {
                        $$ = $1;
                        printf("expr -> literal \n");
                }

        |       expr ARITH_OP expr {
                        $$ = new ArithmeticExpression($1, $2, $3); 
                        printf("expr -> expr ARITH_OP expr \n");
                }

        |       expr REL_OP expr {
                        $$ = new RelationalExpression($1, $2, $3); 
                        printf("expr -> expr REL_OP expr \n");
                }

        |       expr EQ_OP expr {
                        $$ = new EqualExpression($1, $2, $3);
                        printf("expr -> expr EQ_OP expr \n"); 
                }

        |       expr COND_OP expr {
                        $$ = new ConditionalExpression($1, $2, $3);
                        printf("expr -> expr COND_OP expr \n"); 
                }

        |       MINUS expr {
                        $$ = new UnaryExpression($1, $2);
                        printf("expr -> MINUS expr \n");
                } 

        |       NOT expr {
                        $$ = new UnaryExpression($1, $2); 
                        printf("expr -> NOT expr \n");
                } 

        |       LEFT_ROUND expr RIGHT_ROUND {
                        $$ = new EnclosedExpression($2);
                        printf("expr -> LEFT_ROUND expr RIGHT_ROUND \n");
                }

        |       location {
                        $$ = $1;
                        printf("expr -> location \n");
                }

        |       method_call {
                        $$ = $1; 
                        printf("expr -> method_call \n");
                }

literal:        INT_LITERAL {
                        $$ = new IntLiteral($1); 
                        printf("literal -> INT_LITERAL \n");
                }

        |       CHAR_LITERAL {
                        $$ = new CharLiteral($1); 
                        printf("literal -> CHAR_LITERAL \n");
                }

        |       BOOL_LITERAL {
                        $$ = new BoolLiteral($1); 
                        printf("literal -> BOOL_LITERAL \n");
                }

        |       STRING_LITERAL  {
                        $$ = new StringLiteral($1); 
                        printf("literal -> STRING_LITERAL \n");
                }


identifier:     ID{
                        $$ = new Identifier($1);
                        printf("Identifier -> ID \n");
                }

        |       ID LEFT_SQUARE expr RIGHT_SQUARE {
                        $$ = new Identifier_Array($1, $3);
                        printf("identifier -> ID LEFT_SQUARE expr RIGHT_SQUARE \n");
                }
        
        |       ID LEFT_SQUARE expr RIGHT_SQUARE LEFT_SQUARE expr RIGHT_SQUARE {
                        $$ = new Identifier_Array2D($1, $3, $6);
                        printf("identifier -> ID LEFT_SQUARE expr RIGHT_SQUARE LEFT_SQUARE expr RIGHT_SQUARE \n");
                }

location:       
                LID {
                        $$ = new Location($1); 
                        printf("location -> LID \n");
                }

        |       LID LEFT_SQUARE expr RIGHT_SQUARE {
                        $$ = new Location_Array($1, $3);
                        printf("location -> LID LEFT_SQUARE expr RIGHT_SQUARE \n");
                }

        |       LID LEFT_SQUARE expr RIGHT_SQUARE LEFT_SQUARE expr RIGHT_SQUARE {
                        $$ = new Location_Array2D($1, $3, $6);
                        printf("location -> LID LEFT_SQUARE expr RIGHT_SQUARE LEFT_SQUARE expr RIGHT_SQUARE \n");
                }


method_call:    
                CALLOUT LEFT_ROUND STRING_LITERAL COMMA callout_args RIGHT_ROUND {
                        $$ =new MethodCall($3, $5);
                        printf("method_call -> CALLOUT LEFT_ROUND STRING_LITERAL COMMA callout_args RIGHT_ROUND \n"); } 
        |       CALLOUT LEFT_ROUND STRING_LITERAL RIGHT_ROUND {
                        $$ = new MethodCallEmpty($3);
                        printf("method_call -> CALLOUT LEFT_ROUND STRING_LITERAL RIGHT_ROUND \n");}

callout_args:   
                expr {
                        $$ = new CalloutArgs(); 
                        $$->list.push_back($1);
                        printf("callout_args -> exp\n");
                }

        |       callout_args COMMA expr {
                        $$ = $1; $$->list.push_back($3);
                        printf("callout_args -> callout_args COMMA expr\n"); 
                } 

%%
void yyerror(const char *s)
{
        fprintf(stderr, "error: %s\n", s);
}

int main(int argc, char **argv)
{
        printf("------------------\n");
        printf("PARSER OUTPUT\n");
        printf("------------------\n");

        yyparse();
        printf("Parsing Over\n");
        cout << start->name << endl;
        printf("------------------\n");
        printf("AST OUTPUT\n");
        printf("------------------\n");

        PrettyPrint printer;
        
        start->doOp(&printer);
        cout << endl;

        printf("------------------\n");
        printf("INTERPRETER OUTPUT\n");
        printf("------------------\n");
        
        start->interpret();

        printf("------------------\n");
        printf("CODE GENERATION STARTED\n");
        printf("To run:\n");
        printf("llvm-as tinki.ll\n");
        printf("lli tinki.bc\n");
        printf("------------------\n");

        TypeMap.insert({"int", Builder.getInt32Ty()});
        TypeMap.insert({"bool", Builder.getInt1Ty()});
        TypeMap.insert({"char", Builder.getInt8Ty()});
        TypeMap.insert({"string",Builder.getInt8PtrTy()});
        // TypeMap.insert({"void", Builder.getVoidTy()});

        start->Codegen();
        ModuleOb->dump();

        return 0;
}

